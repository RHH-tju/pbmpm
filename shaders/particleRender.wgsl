//-----------------------------------------------------------------------------
// Copyright (c) 2024 Electronic Arts.  All rights reserved.顶点着色器：

计算每个粒子的顶点位置。
根据粒子的位置、半径和渲染模式调整粒子颜色。
输出顶点数据，包括粒子的位置、颜色、半径等信息。
片段着色器：

根据粒子的半径和像素位置计算每个片段的透明度。
使用 smoothstep 函数平滑透明度过渡，减少抗锯齿。
渲染模式：

该着色器支持三种渲染模式：标准渲染、压缩渲染和速度渲染。
每种渲染模式根据粒子的不同物理属性（如密度、速度等）对粒子的颜色进行不同的处理。
//-----------------------------------------------------------------------------

//!include particle.inc
//!include simConstants.inc

// Code-generated by UniformBufferFactory
//!insert RenderConstants

// const values like RenderModeStandard etc
// that are plugged in from js 
//!insert RenderEnums

@group(0) @binding(0) var<uniform> g_constants : RenderConstants;
@group(0) @binding(1) var<storage> g_particles : array<Particle>;


struct VertexOutput {
    @builtin(position) interpolatedVertexPosition : vec4f,
    @location(0) particlePosition : vec2f,
    @location(1) vertexPosition : vec2f,
    @location(2) particleColor : vec3f,
    @location(3) particleRadius : f32,
};

const s_quadVertices = array(
    vec2f(-1, -1),
    vec2f(1, -1),
    vec2f(1, 1),
    vec2f(-1, -1),
    vec2f(1, 1),
    vec2f(-1, 1)
);

const s_antialiasingWidth = 500.0;

@vertex
fn vertexMain(@builtin(vertex_index) vertexId: u32, @builtin(instance_index) instanceId : u32) -> VertexOutput {
    let onePixel = 1.0 / f32(g_constants.canvasSize.x);

    let particle = g_particles[instanceId];

    if(particle.enabled == 0)
    {
        return VertexOutput(
            vec4f(0,0,0,0),
            vec2f(0,0),
            vec2f(0,0),
            vec3f(0,0,0),
            0.0
        );
    }

    var particlePosition : vec2f = particle.position;

    var particleMaterialRadius = g_constants.particleRadiusTimestamp.x * sqrt(particle.volume);

    var quadVertexPosition = s_quadVertices[vertexId] * (1+s_antialiasingWidth*onePixel)*particleMaterialRadius;
    var vertexPosition = quadVertexPosition + particlePosition;

    var vertexPositionInRenderSpace = (vertexPosition - g_constants.viewPos) / g_constants.viewExtent;

    var color = particle.color;

    if(g_constants.renderMode == RenderModeStandard)
    {

    }
    if(g_constants.renderMode == RenderModeCompression)
    {
        let density = particle.liquidDensity;
        color = vec3f(-5*log(density), 5*log(density), color.z);
    }
    else if(g_constants.renderMode == RenderModeVelocity)
    {
        color = vec3f((particle.displacement*g_constants.deltaTime*1000.0 + 0.5f), color.z);
    }

    return VertexOutput(
        vec4f(vertexPositionInRenderSpace, 0, 1),
        particlePosition,
        vertexPosition,
        color,
        particleMaterialRadius,
    );
}

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
    let onePixel = 1.0 / f32(g_constants.canvasSize.x);

    let particleRadius = input.particleRadius;
    let fragmentPosition = input.vertexPosition;
    let fragOffsetFromCenter = fragmentPosition - input.particlePosition;
    let distanceFromCenter = length(fragOffsetFromCenter);

    let alpha = smoothstep(0.0, 1.0, 1-(distanceFromCenter-particleRadius)/(onePixel*s_antialiasingWidth*particleRadius) );

    return vec4f(input.particleColor,alpha);
}
